<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//RU">
<HTML>
<HEAD>
  <LINK rel=stylesheet href="../../css/styles.css" type=text/css>
  <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1251">
  <META HTTP-EQUIV="Content-Language" CONTENT="ru">
  <title>Тема №17</title>
  <base target="_top">
</HEAD>
<BODY>
  <div class="title-1">
    Тема №17 "Обработка ошибок в Java. Исключения"
  </div>
  <div class="content">

    <div class="title-2">
      17.1 Причины возникновения ошибок. 
    </div>
    <p>
      Существует три причины возникновения <i>исключительных ситуаций</i>.
      <ul class="list">
        <li>Попытка выполнить некорректное выражение. Например, деление на ноль, или обращение к объекту по ссылке, равной null, попытка использовать класс, описание которого ( class -файл) отсутствует, и т.д. В таких случаях всегда можно точно указать, в каком месте произошла ошибка, - именно в некорректном выражении.
          <li>Выполнение оператора throw Этот оператор применяется для явного порождения ошибки. Очевидно, что и здесь можно указать место возникновения исключительной ситуации.
            <li>Асинхронные ошибки во время исполнения программы.
            </ul>
          </p>
          <p>
            Причиной таких ошибок могут быть сбои внутри самой виртуальной машины (ведь она также является программой), или вызов метода stop() у потока выполнения Thread.

            В этом случае невозможно указать точное место программы, где происходит исключительная ситуация. Если мы попытаемся остановить поток выполнения (вызвав метод stop() ), нам не удастся предсказать, при выполнении какого именно выражения этот поток остановится.
          </p>
          <div class="title-2">
            17.2 Обработка исключительных ситуаций. Конструкции try-catch и try-catch-finally.
          </div>
          <p>
            <b>Конструкция try-catch</b>
          </p>
          <p>
            В общем случае конструкция выглядит так:
          </p>
          <p>
            <i>
              try {
            </p>
            <p>
             ...
           </p>
           <p>
           } catch(SomeExceptionClass e) {
         </p>
         <p>
           ...
         </p>
         <p>
         } catch(AnotherExceptionClass e) {
       </p>
       <p>
         ...
       </p>
       <p>
       }
     </i>
   </p>
   <p>
    Работает она следующим образом. Сначала выполняется код, заключенный в фигурные скобки оператора <b>try</b>. Если во время его выполнения не происходит никаких нештатных ситуаций, то далее управление передается за закрывающую фигурную скобку последнего оператора catch, ассоциированного с данным оператором try.
  </p>
  <p>
    Если в пределах try возникает исключительная ситуация, то далее выполнение кода производится по одному из перечисленных ниже сценариев.
  </p>
  <p>
    Возникла исключительная ситуация, класс которой указан в качестве параметра одного из блоков<b> catch</b>. В этом случае производится выполнение блока кода, ассоциированного с данным catch (заключенного в фигурные скобки). Далее, если код в этом блоке завершается нормально, то и весь оператор try завершается нормально и управление передается на оператор (выражение), следующий за закрывающей фигурной скобкой последнего catch. Если код в catch завершается не штатно, то и весь try завершается нештатно по той же причине.
  </p>
  <p>
    Если возникла исключительная ситуация, класс которой не указан в качестве аргумента ни в одном catch, то выполнение всего try завершается нештатно.
  </p>
  <p>
    <br>
   <b> Конструкция try-catch-finally</b>
  </p>
  <p>
    Оператор finally предназначен для того, чтобы обеспечить гарантированное выполнение какого-либо фрагмента кода. Вне зависимости от того, возникла ли исключительная ситуация в блоке try, задан ли подходящий блок catch, не возникла ли ошибка в самом блоке catch,- все равно блок <b>finally</b> будет в конце концов исполнен.
  </p>
  <p>
    Последовательность выполнения такой конструкции следующая: если оператор try выполнен нормально, то будет выполнен блок finally. В свою очередь, если оператор finally выполняется нормально, то и весь оператор try выполняется нормально.
  </p>
  <p>
    Если во время выполнения блока try возникает исключение и существует оператор catch, который перехватывает данный тип исключения, происходит выполнение связанного с catch блока. Если блок catch выполняется нормально, либо ненормально, все равно затем выполняется блок finally. Если блок finally завершается нормально, то оператор try завершается так же, как завершился блок catch.
  </p>
  <p>
    Если в списке операторов catch не находится такого, который обработал бы возникшее исключение, то все равно выполняется блок finally. В этом случае, если finally завершится нормально, весь try завершится ненормально по той же причине, по которой было нарушено исполнение try.
  </p>
  <p>
    Во всех случаях, если блок finally завершается ненормально, то весь try завершится ненормально по той же причине.
  </p>
  <div class="title-2">
    17.3 Оператор throw.
  </div>
  <p>

    Помимо того, что предопределенная исключительная ситуация может быть возбуждена исполняющей системой Java, программист сам может явно породить ошибку. Делается это с помощью <b>оператора throw</b>.
  </p>
  <p>
    Метод должен делегировать обработку исключительной ситуации вызвавшему его коду. Для этого в сигнатуре метода применяется ключевое слово throws, после которого должны быть перечислены через запятую все исключительные ситуации, которые может вызывать данный метод. 
  </p>
  <div class="title-2">
    17.4 Проверяемые и непроверяемые исключения.
  </div>
  <p>
    Все исключительные ситуации можно разделить на две категории: <b>проверяемые</b> <i>(checked)</i> и <b>непроверяемые</b><i> (unchecked)</i>.
  </p>
  <p>
    Все исключения, порождаемые от<i> Throwable</i>, можно разбить на три группы. Они определяются тремя базовыми типами: 
    наследниками <i>Throwable</i> - классами <b><i>Error и Exception</i></b>, а также наследником <i>Exception</i> - <b><i>RuntimeException</i></b>.
  </p>
  <p>
    Ошибки, порожденные от Exception (и не являющиеся наследниками RuntimeException ), являются проверяемыми. Т.е. во время компиляции проверяется, предусмотрена ли обработка возможных исключительных ситуаций. Как правило, это ошибки, связанные с окружением программы (сетевым, файловым вводом-выводом и др.), которые могут возникнуть вне зависимости от того, корректно написан код или нет. Например, открытие сетевого соединения или файла может привести к возникновению ошибки и компилятор требует от программиста предусмотреть некие действия для обработки возможных проблем. Таким образом повышается надежность программы, ее устойчивость при возможных сбоях.
  </p>
  <p>
    <br>
    Исключения, порожденные от <i>RuntimeException</i>, являются непроверяемыми и компилятор не требует обязательной их обработки.
  </p>
  <p>
    Как правило, это ошибки программы, которые при правильном кодировании возникать не должны (например, <i>IndexOutOfBoundsException</i> - выход за границы массива, <b>java.lang.ArithmeticException</b> - деление на ноль). Поэтому, чтобы не загромождать программу, компилятор оставляет на усмотрение программиста обработку таких исключений с помощью блоков try-catch.
  </p>
  <p>
    Исключения, порожденные от Error, также не являются проверяемыми. Они предназначены для того, чтобы уведомить приложение о возникновении фатальной ситуации, которую программным способом устранить практически невозможно (хотя формально обработчик допускается). Они могут свидетельствовать об ошибках программы, но, как правило, это неустранимые проблемы на уровне JVM. В качестве примера можно привести <i>StackOverflowError</i> (переполнение стека), OutOfMemoryError (нехватка памяти).
  </p>
  <div class="title-2">
    17.5 Создание пользовательских классов исключений. Переопределение методов и исключения
  </div>
  <p>

    Как уже отмечалось, допускается создание собственных классов исключений. Для этого достаточно создать свой класс, унаследовав его от любого наследника java.lang.Throwable (или от самого Throwable ).
  </p>
  <p>
    Пример:

  </p>
  <p>
      <br><i>
    public class UserException extends Exception {
  </p>
  <p>
   public UserException() {
 </p>
 <p>
  super();
</p>
<p>
}
</p>
<p>
 public UserException(String descry) {
</p>
<p>
  super(descry);
</p>
<p>
}
</p>
<p>
}</i>
</p>



</BODY>
</HTML>