<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//RU">
<HTML>
<HEAD>
    <LINK rel=stylesheet href="../../css/styles.css" type=text/css>
    <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1251">
    <META HTTP-EQUIV="Content-Language" CONTENT="ru">
    <title>Тема №18</title>
    <base target="_top">
</HEAD>
<BODY>
  <div class="title-1">
    Тема №18 "Пакет Java.awt"
</div>
<div class="content">

    <div class="title-2">
        18.1 Апплеты.
    </div>
    <p>
        <b>Апплеты</b> — это маленькие приложения, которые размещаются на серверах Internet, транспортируются клиенту по сети, автоматически устанавливаются и запускаются на месте, как часть документа HTML. Когда апплет прибывает к клиенту, его доступ к ресурсам ограничен.
    </p>
    <p>
        Ниже приведен исходный код канонической программы HelloWorld, оформленной в виде апплета:
    </p>
    <i>
        <br>
        <p>
            import java.awt.*;
        </p>
        <p>
            import java.applet.*;
        </p>
        <p>
            public class HelloWorldApplet extends Applet { 
        </p>
        <p>
            public void paint(Graphics g) {
        </p>
        <p>
            g.drawString("Hello World!", 20, 20);
        </p>
        <p>
        } 
    </p>
    <p>
    }
</i>
</p>
<p>
    Этот апплет начинается двумя строками, которые импортируют все пакеты иерархий <b>java.applet и java.awt.</b> Дальше в нашем примере присутствует метод paint, замещающий одноименный метод класса Applet. При вызове этого метода ему передается аргумент, содержащий ссылку на объект класса Graphics. Последний используется для прорисовки нашего апплета. С помощью метода drawString, вызываемого с этим объектом типа Graphics, в позиции экрана (20,20) выводится строка “Hello World”.
</p>
<p>
    Для того, чтобы с помощью браузера запустить этот апплет, нам придется написать несколько строк html-текста.
</p>

<p>

</p>
<div class="title-2">
    18.2 Базовые классы и основные компоненты графического интерфейса пользователя. 
</div>
<p>
    В Java есть 2 основных пакета для создания графических интерфейсов <b>(Graphics User Interface)</b>. Это <b>Abstract Windows Toolkit (AWT) и Swing. AWT</b> использует виджеты операционной системы, поэтому эта библиотека немного быстрее.

    <p>
        Для группировки компонент интерфейса используются контейнеры <i>(Container)</i>. Для создания основного контейнера для приложения чаще всего используется контейнер 

        <b>JFrame </b>(есть еще JWindows и JApplet). Проще всего унаследоваться от JFrame тем самым получить доступ ко множеству методов, например:
        <ul class="list">
            <li><i>    setBounds(x, y, w, h)</i> - указывает координаты верхней левой вершины окна, а также его ширину и высоту.</li>
            <li><i>    setResizable(bool) </i>- указывает, можно ли изменять размер окна.</li>
            <li><i>   setTitle(str) </i>- устанавливает название окна.</li>
            <li><i>    setVisible(bool)</i> - собственно отображает окно.</li>
            <li><i>    setDefaultCloseOperation(operation) </i>- указывает операцию, которая будет произведена при закрытии окна.</li>
        </ul>
    </p>
    <p>

        Основные элементы управления:
        <ul class="list">
            <li><i>    JLabel </i>- элемент для отображения фиксированного текста;</li>
            <li><i>    JTextField </i>- простой edit-box;</li>
            <li><i>    JButton </i>- обычная кнопка (button);</li>
            <li><i>    JCheckBox </i>- элемент выбора (аналог checkbox);</li>
            <li><i>    JRadioButton </i>- радио кнопка</li>
        </ul>
    </p>
    <p>
        При отображении элементов управления используются специальные менеджеры - <b>LayoutManager</b>. У всех LayoutManager'ов есть методы для добавления у удаления элементов.
        <ul class="list">
            <li><i>FlowLayout </i>- используется для последовательного отображения элементов. Если элемент не помещается в конкретную строку, он отображается в следующей.</li>
            <li><i>GridLayout </i>- отображения элементов в виде таблицы с одинаковыми размерами ячеек.</li>
            <li><i>BorderLayout </i>- используется при отображении не более 5 элементов. Эти элементы располагаются по краям фрейма и в ценрте: North, South, East, West, Center.</li>
            <li><i>BoxLayout </i>- отображает элементы в виде рядка или колонки.</li>
            <li><i>GridBagLayout </i>- позволяет назначать месторасположение и размер каждого виджета. Это самый сложный, но и самый эффективный вид отображения.</li>
        </ul>
    </p>

    <div class="title-2">
        18.3 Менеджеры компоновки. Окна, меню. Обработка событий 
    </div>
    <p>
        Менеджеры компоновки
    </p>
    <p><i>
        <ul class="list">
            <li>    Layout</li>
            <li>    LayoutManager</li>
            <li>    FlowLayout</li>
        </ul></i>
    </p>
    <div class="title-2">
        18.4 Окна, меню.
    </div>

    <p>
        <b><i>Класс Window</i></b> во многом напоминает Panel за тем исключением, что он создает свое собственное окно верхнего уровня. Большая часть программистов скорее всего будет использовать не непосредственно класс Window, а его подкласс <i>Frame</i>.

    </p>
    <p>
        <b><i>Frame</i></b> - это как раз то, что обычно и считают окном на рабочей поверхности экрана. У объекта Frame есть строка с заголовком, управляющие элементы для изменения размера и линейка меню. Для того чтобы вывести/спрятать изображение объекта Frame, нужно использовать методы show и hide. Ниже приведен пример апплета, который показывает объект Frame с содержащимся в нем компонентом TextArea.
    </p>
    <p>
        С каждым окном верхнего уровня может быть связана линейка меню. Объект <b><i>MenuBar</i></b> может включать в себя несколько объектов Menu. Последние, в свою очередь, содержат в себе список вариантов выбора - объектов MenuItem. Menu - подкласс MenuItem, так что объекты Menu также могут включаться в этот список, что позволяет создавать иерархически вложенные подменю. Вот пример, в котором к окну добавлены несколько вложенных меню.
    </p>
    <div class="title-2">
        18.5 Обработка событий 
    </div>
    <p>

        <b><i>Модель обработки событий</i></b> в AWT представляет собой, по существу, модель обратных вызовов (callback). При создании GUI-элементаему сообщается, какой метод или методы он должен вызывать при возникновении в нем определенного события (нажатия кнопки, мыши и т.п.). Эту модель очень легко использовать в C++, поскольку этот язык позволяет оперировать указателями на методы (чтобы определить обратный вызов, необходимо всего лишь передать указатель на функцию). Однако в Java это недопустимо (методы не являются объектами). Поэтому для реализации модели необходимо определить класс, реализующий некоторый специальный интерфейс. Затем можно передать экземпляр такого класса GUI-элементу,обеспечивая таким образом обратный вызов. Когда наступит ожидаемое событие,GUI-элементвызовет соответствующий метод объекта, определенного ранее.
    </p>
    <p>
        Модель обработки событий Java используется как в пакете AWT, так и в JavaBeans API. В этой модели разным типам событий соответствуют различные классы Java. Каждое событие является подклассом класса <b>java.util.EventObject</b>. События пакета AWT, которые и рассматриваются в данной главе, являются подклассом java.awt.AWTEvent. Для удобства события различных типов пакета AWT (например, MouseEvent или АсtionEvent) помещены в новый пакет java.awt.event.
    </p>
    <p>
        Модель обработки событий Java базируется на <b>концепции слушателя событий</b>. <i>Слушателем</i> события является<i> объект</i>, заинтересованный в получении данного события. В объекте, который порождает событие (в источнике событий), содержится список слушателей, заинтересованных в получении уведомления о том, что данное событие произошло, а также методы, которые позволяют слушателям добавлять или удалять себя из этого списка. Когда <i>источник</i> порождает событие (или когда объект источника зарегистрирует событие, связанное с вводом информации пользователем), он оповещает все объекты слушателей событий о том, что данное событие произошло.
    </p>
    <p>
        Источник события оповещает объект слушателя путем вызова специального метода и передачи ему объекта события (экземпляра подкласса EventObject). Для того чтобы источник мог вызвать данный метод, он должен быть реализован для каждого слушателя. Это объясняется тем, что все слушатели событий определенного типа должны реализовывать соответствующий интерфейс. Например, объекты слушателей событий
    </p>



</BODY>
</HTML>