    <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//RU">
    <HTML>
    <HEAD>
        <LINK rel=stylesheet href="../../css/styles.css" type=text/css>
        <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1251">
        <META HTTP-EQUIV="Content-Language" CONTENT="ru">
        <title>Тема №3</title>
        <base target="_top">
    </HEAD>
    <BODY>
      <div class="title-1">
        Тема №3 "Реализация стандартной библиотеки MPI"
    </div>
    <div class="content">
        <div class="title-2">
            3.1 Механизмы времени выполнения среды ParJava
        </div>
        <p>
            Для обеспечения возможности использования среды Java на высокопроизводительных кластерных системах были реализованы <b>стандартная библиотека MPI и механизм контрольных точек</b>.
            <p>
                Первой задачей, которую было необходимо решить при разработке среды ParJava, была <i>эффективная реализация стандартной библиотеки MPI для окружения Java</i>. В настоящее время известно несколько реализаций библиотеки MPI для окружения Java, но ни одна из этих реализаций не обеспечивает достаточно эффективных обменов данными. Кроме того, в них реализованы не все функции библиотеки MPI. Поэтому для среды ParJava была разработана оригинальная реализация библиотеки MPI для окружения Java - <b>библиотека mpiJava</b>.
            </p>
            <p>
                В настоящее время в библиотеке mpiJava поддерживаются все функции стандарта MPI 1.1, а также параллельные операции ввода-вывода из стандарта MPI 2.
            </p>
            <p>
               Библиотека mpiJava реализована путем «привязки» (binding) к существующим реализациям библиотеки MPI с помощью <i>интерфейса JNI </i> по аналогии с «привязкой» для C++, описанной в стандарте MPI 2.
           </p>
           <p>
               Начиная с версии 1.4, в Java поддерживаются прямые буферы, содержимое которых может находиться в памяти операционной системы (вне кучи Java). Использование прямых буферов при передаче данных позволяет избежать <i>лишних копирований данных</i>. Это позволяет сократить накладные расходы на передачу данных.
           </p>
           <div class="title-2">
            3.1 Механизм контрольных точек
        </div>

        <p>
            В среде ParJava реализован инструмент<b> “CheckPoints”</b>, реализующий механизм контрольных точек, который позволяет существенно<i> сократить объемы сохраняемых данных и время на их сохранение</i>.
        </p>
        <p>
            Реализация механизма контрольных точек для параллельной программы является нетривиальной задачей. Параллелизм усложняет процесс установки точек останова, т. к. сообщения порождают связи между отдельными процессами, и приходится обеспечивать так называемые консистентные состояния. Состояние двух процессов называется неконсистентным, если при передаче сообщения одного процесса другому, может возникнуть состояние, когда первый процесс еще не послал сообщение, а во втором уже сработала функция получения сообщения. Если в таком состоянии поставить точку останова, то восстановив впоследствии контекст задачи, мы не получим ее корректной работы.
        </p>    
        <p>
            Пользователь указывает в программе место сохранения данных с помощью директивы EXCLUDE_HERE. В контрольной точке 1  не сохраняются данные, которые будут обновлены до своего использования <i>(«мертвые» переменные)</i>. В контрольной точке 2 не сохраняются данные, которые используются только для чтения до этой контрольной точки. Результатом будет значительное уменьшение размеров сохраняемых данных в контрольной точке и уменьшение накладных расходов на их сохранение.
        </p>


    </BODY>
</HTML>