<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//RU">
<HTML>
<HEAD>
	<LINK rel=stylesheet href="../../css/styles.css" type=text/css>
	<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1251">
	<META HTTP-EQUIV="Content-Language" CONTENT="ru">
	<title>Тема №20</title>
	<base target="_top">
</HEAD>
<BODY>
	<div class="title-1">
		Тема №20 "Потоки выполнения. Синхронизация"
	</div>
	<div class="content">
		<div class="title-2">
			20.1 Многопоточная архитектура

		</div>
		<p>
			<b>Многопоточность</b> — свойство платформы (например, операционной системы, виртуальной машины и т. д.) или приложения, состоящее в том, что процесс, порождённый в операционной системе, может состоять из <i>нескольких потоков, выполняющихся «параллельно»</i>, то есть без предписанного порядка во времени. При выполнении некоторых задач такое разделение может достичь более эффективного использования ресурсов вычислительной машины.
			Для запуска потоков (можете улыбнуться) существует специальный класс — <b>Thread (поток)</b>.
		</p>
		<p>
			<b>Жизненный цикл потока</b>
		</p>
		<p>
			<br>
			При выполнении программы объект класса <i>Thread</i> может быть в одном из четырех основных состояний: <i>«новый», «работоспособный», «неработоспособный» и «пассивный». </i>При создании потока он получает состояние <i>«новый» </i>(NEW) и не выполняется. Для перевода потока из состояния <i>«новый»</i> в состояние <i>«работоспособный»</i> (RUNNABLE) следует выполнить метод start(), который вызывает метод run() — основной метод потока.
		</p>
		<p>
			Поток может находиться в одном из состояний, соответствующих элементам статически вложенного перечисления<b><i> Thread.State:</i></b>
		</p>
		<p>
			<ul class="list">
				<li><i>new</i> — поток создан, но еще не запущен;</li>
				<li><i>runnable</i> — поток выполняется;</li>
				<li><i>blocked</i> — поток блокирован;</li>
				<li><i>waiting</i> — поток ждет окончания работы другого потока;</li>
				<li><i>timed_waiting</i> — поток некоторое время ждет окончания другого потока;</li>
				<li><i>terminated </i>— поток завершен.</li>
			</ul>
		</p>
		<p>
			Получить текущее значение состояния потока можно вызовом метода <b><i>getState()</i></b>.
		</p>

		<div class="title-2">
			20.2 Работа с приоритетами. Демон-потоки.
		</div>
		<p>
			<b>Приоритеты</b>
		</p>
		<p>
			Планировщик определяет, какой поток должен запуститься, основываясь на номер приоритета, назначенный каждому потоку. Приоритет потока может принимать значения от 1 до 10. По умолчанию, значение приоритета для потока является <b>Thread.NORM_PRIORITY</b>, которому соответствует значение 5. Так же доступны две других static переменных: <b>Thread.MIN_PRIORITY</b>, значение 1, и <b>Thread.MAX_PRIORITY</b> – 10. Метод <b><i>getPriority()</i></b> может использоваться для получения текущего значения приоритета соответствующего потока.
		</p>
		<p>
			<b>Демон-потоки</b>
			Такие потоки иногда ещё называются <b>“службами”</b>, которые обычно запускаются с наименьшим приоритетом и обеспечивают основные услуги для программы или программ, когда деятельность компьютера понижается. Примером такого потока может служить <i>сборщик мусора</i>. Этот поток, предусмотрен JVM, сканирует программы на наличие переменных, к которым больше никогда не придется обращаться, и освобождает их ресурсы, возвращая их системе. Поток может стать <i>daemon</i> потоком, передав булево значение true в метод <i>setDaemon()</i>. Если принято значение false, то поток становится обычным пользовательским потоком. Тем не менее, это необходимо сделать до того как поток запустится.
		</p>
		<div class="title-2">
			20.3 Модификатор volatile.
		</div>
		<p>
			Модификатор <b>volatile</b> используются в Java для потоков.
		</p>
		<p>
			В Java модификатор <i>volatile</i> используется, чтобы позволить знать JVM, что поток доступа к переменной всегда должен объединять свою собственную копию переменной с главной копией в памяти.
		</p>
		<p>
			Доступ к переменной volatile синхронизирует все кэшированные скопированные переменные в оперативной памяти. Volatile может быть применен только к переменным экземпляра, которые имеют тип объект или private. Ссылка на объект volatile может быть null.
			Как правило, <b><i>run()</i></b> вызывается в одном потоке (впервые начинаете использовать Runnable в Java), а stop() вызывается из другого потока. Если в линии 1 используется кэшированное значение active, то цикл не может остановиться, пока Вы не установите active false в линии 2.
		</p>

		<div class="title-2">
			20.3 Блокировки, методы wait, notify, notifyAll

		</div>
		<p>
			<b>Класс Object</b> в Java содержит три <b><i>final </i></b>метода для взаимодействия потоков. Это методы<b> wait(), notify() и notifyAll().</b>
		</p>
		<br>

		<p>
			У <b>метода wait()</b> есть три вариации. Один метод wait() бесконечно ждет другой поток, пока не будет вызван метод notify() или notifyAll() на объекте. Другие две вариации метода wait() ставят текущий поток в ожидание на определенное время. По истечении этого времени поток просыпается и продолжает работу.
		</p>

		<p>
			Вызов<b> метода notify()</b> пробуждает только один поток, после чего этот поток начинает выполнение. Если объект ожидают несколько потоков, то метод notify() разбудит только один из них. Выбор потока зависит от системной реализации управления потоками.
		</p>

		<p>
			Метод <b>notifyAll()</b> пробуждает все потоки, хотя в какой последовательности они будут пробуждаться зависит от реализации ОС.
		</p>

	</BODY>
</HTML>