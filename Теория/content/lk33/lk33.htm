<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//RU">
<HTML>

<HEAD>
    <LINK rel=stylesheet href="../../css/styles.css" type=text/css>
    <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1251">
    <META HTTP-EQUIV="Content-Language" CONTENT="ru">
    <title>Тема №33</title>
    <base target="_top">
</HEAD>

<BODY>
    <div class="title-1">
        Тема №33 "Логирование, кеширование, транзакционность"
    </div>
    <div class="content">
        <p>
            Под
            <b>транзакцией</b> понимается ряд действий, которые воспринимаются системой, как единый пакет, т.е. или все действия
            проходят успешно, или все откатываются на исходные позиции. Существует два вида транзакций: глобальные и локальные.
        </p>
        <p>
            <i>Глобальные</i> транзакции позволяют работать с несколькими транзакционными ресурсами, как правило, реляционными
            базами данных и очередью сообщений. Сервер приложений управляет глобальными транзакциями через JTA, который является
            громоздким API( частично из­за его модели исключений ) . Кроме того, JTA UserTransaction как правило должен быть
            получен из JNDI, а это означает, что также необходимо использовать JNDI для того, чтобы использовать JTA . Очевидно,
            что использование глобальных транзакций будет ограничивать любое потенциальное повторное использование кода приложения,
            так как JTA, как правило, доступен только на сервере приложений.
        </p>
        <p>
            <i>Локальные</i> транзакции являются ресурсо­специфичными, такие как транзакции связанные с JDBC соединением. Недостатком
            локальных транзакций является то, что они работают только с одним источником. Например, код, который управляет
            транзакций с использованием соединения JDBC не может работать в рамках глобальной транзакции JTA. Поскольку сервер
            приложений не участвует в управлении транзакциями, он не может помочь обеспечить корректность по нескольким ресурсам.
            Другим недостатком является то, что локальные транзакции являются инвазивными к модели программирования.
        </p>
        <br>
        <p>
            В любом разрабатываемом приложении мы можем в какой-то момент столкнутся с проблемой производительности. Один из способов
            решения проблем — это кеширование. Естественно можно кешировать данные возвращаемые из базы данных (Hibernate
            — наиболее используемый в java делает это и так) — но намного интересней — это кеширование значений возвращаемых
            с уровня «сервисов». Вычисление таких значений может быть достаточно трудоемким, включать множество вызовов к
            базе данных, другим сервисам, вычислений — и соответсвенно кеширование на этом уровне может привести к более
            весомым результатам.
        </p>
        <p>
            В Spring Framework 3.1 это можно будет сделать с помощью аннотации @Cacheable На самом деле — кеширование на уровне сервисов
            можно было сделать в Spring Framework и раньше, просто теперь это станет намного проще.
        </p>
        <p>
            Кешировать данные надо аккуратно — это всегда потенциальный источник ошибок, когда данные обновились, а кеш нет и приложение
            использует устаревшие данные. Очистка кеша тоже может быть выполнена при помощи аннотации — @CacheEvict:
        </p>
        <p>
            @CacheEvict(value = "books", allEntries=true)
        </p>
        <p>
            public void loadBooks(InputStream batch)
        </p>
        <br>
        <p>
            Лог (или, по-другому, логи сервера, лог файл, данные словосочетания являются синонимами) – это файл текстового формата, в
            который заносятся все данные обо всех действиях любых пользователей на серверах, будь то локальные сервера какой-либо
            организации или веб-сервера некоего хост-провайдера, на котором работают сайты, или FTP-сервер Вашей районной
            сети.
        </p>
        <p>
            Log4J – фреймворк для скрытия реализации рутинных операций по логированию (журналированию) некоторых событий, которые происходят
            во время работы Вашего приложения.
        </p>
        <br>
        <p>
            Создание логгера:
        </p>
        <p>
            Logger log = LogManager.getLogger(LoggingLog4j.class);
        </p>
        <p>
            <i>или</i>
        </p>
        <p>
            Logger log = LogManager.getLogger(“name”);
        </p>
        <br>
        <p>
            Log4j имеет уровней логгирования: TRACE, DEBUG, INFO, WARN, ERROR, FATAL, а так же ALL и OFF включающий и отключающий все
            уровни соответственно.
        </p>
    </div>
</BODY>

</HTML>