<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//RU">
<HTML>
<HEAD>
<LINK rel=stylesheet href="../../css/styles.css" type=text/css>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1251">
<META HTTP-EQUIV="Content-Language" CONTENT="ru">
<title>Тема №15</title>
<base target="_top">
</HEAD>
<BODY>
  <div class="title-1">
    Тема №15 "Объявление классов в Java"
  </div>
  <div class="content">

    <div class="title-2">
        15.1 Модификаторы доступа. 
    </div>
    <p>
        В Java существуют следующие модификаторы доступа:

private: члены класса доступны только внутри класса;
default (package-private) (модификатор, по-умолчанию): члены класса видны внутри пакета (если класс будет так объявлен он будет доступен только внутри пакета);
protected: члены класса доступны внутри пакета и в наследниках;
public: члены класс доступны всем;
Последовательность модификаторов по убыванию уровня закрытости: private, default ,protected, public).

Модификатор доступа по умолчанию — означает, что мы явно не объявляем модификатор доступа в Java для класса, поля, метода и т.д.

Переменная или метод, объявленные без модификатора контроля доступа доступны для любого другого класса в том же пакете. Поля в интерфейсе неявно являются public, static, final, а методы в интерфейсе по умолчанию являются public.
    </p>
        <div class="title-2">
        15.2 Объявление классов. 
    </div>
    <p>
        Объявление класса состоит из заголовка и тела класса.

3.1. Заголовок класса
Вначале указываются модификаторы класса. Модификаторы доступа для класса уже обсуждались. Допустимым является public, либо его отсутствие - доступ по умолчанию.

Класс может быть объявлен как final. В этом случае не допускается создание наследников такого класса. На своей ветке наследования он является последним. Класс String и классыобертки, например, являются final-классами.

После списка модификаторов указывается ключевое слово class, а затем имя класса - корректный Java-идентификатор.Таким образом, кратчайшим объявлением класса может являться такой модуль компиляции:

class A {}

 Тело класса
Тело класса может содержать объявление элементов (members) класса:

•полей;

•методов;

•внутренних типов (классов и интерфейсов);

и остальных допустимых конструкций:

•конструкторов;

•инициализаторов;

•статических инициализаторов.
    </p>
        <div class="title-2">
        15.3 Дополнительные свойства классов: метод main, параметры методов, перегруженные методы
    </div>
    <p>

Метод main
Итак, виртуальная машина реализуется приложением операционной системы и запускается по обычным правилам. Программа, написанная на Java, является набором классов. Понятно, что требуется некая входная точка, с которой должно начинаться выполнение приложения.

Такой входной точкой, по аналогии с языками C/C++, является метод main(). Пример его объявления:

public static void main(String[] args) {

}

Модификатор static в этой главе не рассматривался и будет изучен позже. Он позволяет вызвать метод main(), не создавая объектов. Метод не возвращает никакого значения, хотя в C есть возможность указать код возврата из программы. В Java для этой цели есть метод System.exit(), который закрывает виртуальную машину и имеет аргумент типа int.

Аргументом метода main() является массив строк. Он заполняется дополнительными параметрами, которые были указаны при вызове метода.

package test.first;

public class Test {

public static void main(String[] args) { for (int i=0; i<'args.length; i++) { System.out.print(args[i]+" ");

}

System.out.println();

}

}

Для вызова программы виртуальной машине передается в качестве параметра имя класса, у которого объявлен метод main(). Поскольку это имя класса, а не имя файла, то не должно быть указано никакого расширения (.class или .java), а расположение класса записывается через точку (разделитель имен пакетов), а не с помощью файлового разделителя. Компилятору же, напротив, передается именно имя и путь к файлу.

Если вышеприведенный модуль компиляции сохранен в файле Test.java, который лежит в директории test\first, то вызов компилятора записывается следующим образом:
javac test\first\Test.java

А вызов виртуальной машины:

java test.first.Test

Чтобы проиллюстрировать работу с параметрами, изменим строку запуска приложения:

java test.first.Test Hello, World!

Результатом работы программы будет:

Hello, World!

4.2. Параметры методов
Для лучшего понимания работы с параметрами методов в Java необходимо рассмотреть несколько вопросов.

Во-первых,как передаются аргументы в методы - по значению или по ссылке? С точки зрения программы вопрос формулируется, например, следующим образом. Пусть есть переменная, и она в качестве аргумента передается в некоторый метод. Могут ли произойтикакие-либоизменения с этой переменной после завершения работы метода?

int x=3; process(x); print(x);

Предположим, используемый метод объявлен следующим образом:

public void process(int x) { x=5;

}

Какое значение появится на консоли после выполнения примера? Чтобы ответить на этот вопрос необходимо вспомнить, как переменные разных типов хранят свои значения в Java.

Напомним, что примитивные переменные являются истинными хранилищами своих значений, и изменения значения одной переменной никогда не скажется на значении другой. Параметр метода process(), хоть и имеет такое же имя x, на самом деле является полноценным хранилищем целочисленной величины. А потому присвоение ему значения 5 не скажется на внешних переменных. То есть, результатом примера будет 3, и аргументы примитивного типа передаются в методы по значению. Единственный способ изменить такую переменную в результате работы метода - возвращать нужные величины из метода и использовать их при присвоении:

public int double(int x) { return x+x;

}
public void test() { int x=3; x=double(x);

}

Перейдем к ссылочным типам.

public void process(Point p) { p.x=3;

}

public void test() {

Point p = new Point(1,2); process(p);

print(p.x);

}

Ссылочная переменная хранит ссылку на объект, находящийся в памяти виртуальной машины. Поэтому аргумент метода process() будет иметь своим значением ту же самую ссылку и, стало быть, ссылаться на тот же самый объект. Изменения состояния объекта, осуществленные с помощью одной ссылки, всегда видны при обращении к этому объекту с помощью другой. Поэтому результатом примера будет значение 3. Объектные значения передаются в Java по ссылке.

Однако если изменять не состояние объекта, а саму ссылку, то результат будет другим:

public void process(Point p) { p = new Point(4,5);

}

public void test() {

Point p = new Point(1,2); process(p);

print(p.x);

}

В этом примере аргумент метода process() после присвоения начинает ссылаться на другой объект, нежели исходная переменная p, а значит, результатом примера станет значение 1. Можно сказать, что ссылочные величины передаются по значению, но значением является именно ссылка на объект.

Теперь можно уточнить, что означает возможность объявлять параметры методов и конструкторов как final. Поскольку изменения значений параметров (но не объектов, на которые они ссылаются) никак не сказываются на переменных вне метода, то модификатор final говорит лишь о том, что значение этого параметра не будет меняться на протяжении работы метода. Разумеется, для аргумента final Point p выражение p.x=5 является допустимым (запрещается p=new Point(5, 5)).

4.3. Перегруженные методы
Перегруженными (overloading) методами называются методы одного класса с одинаковыми именами. Сигнатуры у них должны быть различными, и различие может быть только в наборе аргументов.

Если в классе параметры перегруженных методов заметно различаются, например, у одного метода один параметр, у другого - два, то для Java это совершенно независимые методы, и совпадение их имен может служить только для повышения наглядности работы класса. Каждый вызов в зависимости от количества параметров однозначно адресуется к тому или иному методу.

Однако, если количество параметров одинаковое, а типы их различаются незначительно, но при вызове может сложиться двойственная ситуация, когда несколько перегруженных методов одинаково хорошо подходят для использования. Например, если объявлены типы Parent и Child, где Child расширяет Parent, то для следующих двух методов:

void process(Parent p, Child c) {} void process(Child c, Parent p) {}

можно сказать, что они допустимы, их сигнатуры различаются. Однако при вызове

process(new Child(), new Child());

обнаруживается, что оба метода одинаково годятся для использования. Другой пример, методы:

process(Object o) {} process(String s) {}

и примеры вызовов:

process(new Object()); process(new Point(4,5)); process("abc");

Легко видеть, что для первых двух вызовов подходящим является только первый метод, и именно он будет вызван. Для последнего же вызова подходят оба перегруженных метода, однако класс String является более "специфичным", или узким, чем класс Object. Действительно, значения типа String можно передавать в качестве аргументов типа Object, обратное же неверно. Компилятор попытается отыскать наиболее специфичный метод, подходящий для указанных параметров, и вызовет именно его. Поэтому при третьем вызове будет использован второй метод.

Однако для предыдущего примера такой подход не дает однозначного ответа. Оба метода одинаково специфичны для указанного вызова, и поэтому возникнет ошибка компиляции. Необходимо, используя явное приведение, указать компилятору, какой метод необходимо использовать:

process((Parent)(new Child()), new Child());
// или

process(new Child(),(Parent)(new Child()));

Это верно и в случае использования значения null:

process((Parent)null, null); // или process(null,(Parent)null);
 
    </p>


</BODY>
</HTML>