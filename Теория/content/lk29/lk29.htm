<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//RU">
<HTML>

<HEAD>
    <LINK rel=stylesheet href="../../css/styles.css" type=text/css>
    <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1251">
    <META HTTP-EQUIV="Content-Language" CONTENT="ru">
    <title>Тема №29</title>
    <base target="_top">
</HEAD>

<BODY>
    <div class="title-1">
        Тема №29 "JPA, Hibernate"
    </div>
    <div class="content">
        <p>
            <b>JPA</b> (Java Persistence API) - это спецификация Java EE и Java SE, описывающая систему управления сохранением
            java-объектов в таблицы реляционных баз данных в удобном виде. Сама Java не содержит реализации JPA, однако существует
            много реализаций данной спецификации от разных компаний (открытых и нет). Это не единственный способ сохранения
            java объектов в базы данных (ORM систем), но один из самых популярных в Java мире.
        </p>
        <p>
            У JPA существуют разные реализации:
            <ul class="list">
                <li>Hibernate </li>
                <li>Oracle TopLink</li>
                <li>Apache OpenJPA </li>
            </ul>
        </p>
        <p>
            <b>Hibernate</b> - это механизм отображения в реляционной базе данных объектов java. Hibernate не только заботится
            об отражении классов Java в таблицы БД (и типов данных Java в типы данных SQL), но также обеспечивает запрос
            данных и поисковые средства и может значительно сократить время разработки которое тратится на ручное написание
            SQL и JDBC кода.
        </p>
        <p>
            <u>Основные возможности:</u>
            <ol class="list">
                <li>Автоматическая генерация и обновление таблиц в БД.</li>
                <li>Поскольку основные запросы к БД представлены как методы Hibernate, то значительно сокращается код.</li>
                <li>Обеспечение использование SQL подобного языка. </li>
            </ol>
        </p>
        <p>
            При связи
            <b>один-­к­-одному</b> каждая запись в одной таблице напрямую связана с отдельной записью в другой таблице. Для
            того, чтобы связать сущности отношением один­-к-­одному в Hibernate используется аннотация @OneToOne. В целом,
            может быть 3 варианта ее использования:
            <ul class="list">
                <li>связанные сущности используют одно и тоже значение первичного ключа; </li>
                <li>внешний ключ определяется полем одной из сущностей (это поле в БД должно быть уникальным для имитации отношения
                    один­к­одному);
                </li>
                <li>используется таблица для хранения ссылки между двумя сущностями (ограничение уникальности должно быть установлено
                    на каждом из полей для того, чтобы соответствовать кратности один­-к-­одному).</li>
            </ul>
        </p>
        <p>
            Ассоциация
            <b>один­-ко-­многим</b> возникает тогда, когда каждой записи в таблице А, соответствует множество записей в таблице
            Б, но каждая запись в таблице Б имеет лишь одну соответствующую запись в таблице А.
        </p>
        <br>
        <p>
            Связь
            <b>многие-­ко-­многим</b> используется, когда записи из таблицы А может соответствовать 0 или более записей в таблице
            Б и наоборот для каждой записи из Б есть 0 или более записей таблицы А.
        </p>
        <br>
        <p>
            Интерфейс
            <i>org.hibernate.Session</i> является мостом между приложением и Hibernate. С помощью сессий выполняются все CRUD-операции
            с объектами-сущностями. Объект типа Session получают из экземпляра типа org.hibernate.SessionFactory, который
            должен присутствовать в приложении в виде singleton.
        </p>
        <p>
            <b>Состояния объектов</b>
        </p>
        <p>
            Объект-сущность может находиться в одном из 3-х состояний (статусов):
            <ul class="list">
                <li>
                    <i>transient object.</i> Объекты в данном статусе — это заполненные экземпляры классов-сущностей. Могут
                    быть сохранены в БД. Не присоединены к сессии. Поле Id не должно быть заполнено, иначе объект имеет статус
                    detached;
                </li>
                <li>
                    <i>persistent object.</i> Объект в данном статусе — так называемая хранимая сущность, которая присоединена
                    к конкретной сессии. Только в этом статусе объект взаимодействует с базой данных. При работе с объектом
                    данного типа в рамках транзакции все изменения объекта записываются в базу;</li>
                <li>
                    <i>detached object.</i> Объект в данном статусе — это объект, отсоединённый от сессии, может существовать
                    или не существовать в БД.
                </li>
            </ul>
        </p>
        <p>
            Любой объект-сущность можно переводить из одного статуса в другой. Для этого в интерфейсе Session существуют следующие методы:
            <ul class="list">
                <li>
                    <i>persist(Object)</i> — преобразует объект из transient в persistent, то есть присоединяет к сессии и сохраняет
                    в БД. Однако, если мы присвоим значение полю Id объекта, то получим PersistentObjectException — Hibernate
                    посчитает, что объект detached, т. е. существует в БД. При сохранении метод persist() сразу выполняет
                    insert, не делая select.</li>
                <li>
                    <i>merge(Object)</i> — преобразует объект из transient или detached в persistent. Если из transient, то
                    работает аналогично persist() (генерирует для объекта новый Id, даже если он задан), если из detached
                    — загружает объект из БД, присоединяет к сессии, а при сохранении выполняет запрос update</li>
                <li>
                    <i>replicate(Object, ReplicationMode)</i> — преобразует объект из detached в persistent, при этом у объекта
                    обязательно должен быть заранее установлен Id. Данный метод предназначен для сохранения в БД объекта
                    с заданным Id, чего не позволяют сделать persist() и merge()</li>
                <li>
                    <i>delete(Object)</i> — удаляет объект из БД, иными словами, преобразует persistent в transient. Object
                    может быть в любом статусе, главное, чтобы был установлен Id.</li>
                <li><i>save(Object)</i> — сохраняет объект в БД, генерируя новый Id, даже если он установлен. Object может быть в статусе
                    transient или detached</li>
                <li><i>update(Object)</i> — обновляет объект в БД, преобразуя его в persistent (Object в статусе detached)</li>
                <li><i>saveOrUpdate(Object)</i> — вызывает save() или update()</li>
                <li><i>refresh(Object)</i> — обновляет detached-объект, выполнив select к БД, и преобразует его в persistent</li>
                <li><i>get(Object.class, id)</i> — получает из БД объект класса-сущности с определённым Id в статусе persistent</li>
            </ul>
        </p>
        <p>
            <b>Выборка с условиями</b>
        </p>
        <p>
            Для выборки с условием в Hibernate используются объекты org.hibernate.Criteria:
        </p>
        <p>
            ...
        </p>
        <p>
            <i>Session session = sessionFactory.openSession();</i>
        </p>
        <p>
            <i>Criteria userCriteria = session.createCriteria(User.class);</i>
        </p>
        <p>
            <i>userCriteria.add(Restrictions.eq("login", login));</i>
        </p>
        <p>
            <i>user = (User) userCriteria.uniqueResult();</i>
        </p>
        <p>
            <i>session.close();</i>
        </p>
        <p>
            ...
        </p>
    </div>
</BODY>

</HTML>