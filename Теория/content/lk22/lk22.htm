<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//RU">
<HTML>
<HEAD>
<LINK rel=stylesheet href="../../css/styles.css" type=text/css>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1251">
<META HTTP-EQUIV="Content-Language" CONTENT="ru">
<title>Тема №22</title>
<base target="_top">
</HEAD>
<BODY>
  <div class="title-1">
    Тема №22 "Сервера приложений"
  </div>
  <div class="content">
    <div class="title-2">
        22.1 Понятия поток и процесс
    </div>
    <p>
      При помощи <b>многопоточности</b> можно выделить в приложении несколько потоков, которые
      будут выполнять различные задачи одновременно. Если у нас графическое приложение, которое посылает запрос к какому-нибудь серверу или считывает и обрабатывает огромный файл, то без многопоточности у нас бы блокировался графический интерфейс на время выполнения задачи. А благодаря потокам мы можем выделить отправку запроса или любую другую задачу, которая может долго обрабатываться, в отдельный поток. Поэтому большинство реальных приложений, которые многим из нас приходится использовать, практически немыслимы без многопоточности.
    </p>
    <p>  
      <b><i>Процесс</i></b> – объект, который создается ОС, когда пользователь запускает приложение. Ему выделяется адресное пространство, но это пространство физически недоступно для других процессов.
    </p>
    <p>   
      <b><i>Поток</i></b> – определенный способ выполнения процесса.
    </p>
    <div class="title-2">
        21.2 Методы коммуникации между потоками и процессами инструментами JAVA
    </div>
    <p>
        Для каждого процесса ОС создает один главный поток. При необходимости главный поток может создавать другие потоки.
        Все потоки, созданные процессом, выполняются в адресном пространстве этого процесса и имеют доступ к ресурсам процесса, но не имею доступа к потокам другого процесса.
        Операционная система, имея доступ ко всем областям памяти, играет роль посредника в
        информационном обмене прикладных потоков. При необходимости в обмене данными поток обращается с запросом к ОС. ОС, пользуясь своими привилегиями, создает различные системные средства связи. Многие из средств межпроцессного обмена данными выполняют также и функции синхронизации: в том случае, когда данные для процесса получателя
        отсутствуют, последний переводится в состояние ожидания средствами ОС, а при поступлении данных от процесса отправителя процесс получатель активизируется.        
    </p>
    <p>
      Передача может осуществляться несколькими способами:
      <ul class="list">
        <li>разделяемая память?</li>
        <li>канал— псевдофайл, в который один процесс пишет, а другой читает?</li>
        <li>сокеты— поддерживаемый ядром механизм, скрывающий особенности среды и позволяющий единообразно взаимодействовать процессам, как на одном компьютере, так и в сети?</li>
        <li>почтовые ящики (только в Windows), однонаправленные, возможность широковещательной рассылки?</li>
        <li>вызов удаленной процедуры, процесс А Может вызвать процедуру в процессе В, и получить обратно данные.</li>
      </ul>
    </p>
    <p>
        При работе потоки нередко обращаются к каким-то общим ресурсам, которые определены вне потока, например,обращения к какому-то файлу. Если одновременно несколько потоков обратятся к общему ресурсу, то результаты программы могут быть непредсказуемыми. 
        Для избежания этой проблемы следует <i>синхронизировать потоки</i>.
    </p>
    <p>
        Эффект синхронизации достигается за счет применения механизма блокировки (lock). Каждому объекту в Java ставится в соответствие свойство блокировки lock. 
    </p>
    <p>
        <b><i>Lock</i></b> — специальная переменная в области памяти, выделяемой Java-машиной при создании объекта. Потоки взаимодействуют в соответствии с протоколом, согласно которому любому действию над объектом должен предшествовать захват права на блокировку объекта. Если поток захватил такое право (установил блокировку объекта), то другие потоки не могут использовать объект, пока право не будет возвращено потоком владельцем, то есть пока блокировка не будет освобождена.
    </p>
    <div class="title-2">
        21.3 Синхронизация через synchronized
    </div>
    <p>
        Право доступа к блокировке объекта обеспечивается в Java с помощью ключевого слова <i>synchronized</i>. Использование ключевого слова <i>synchronized</i> гарантирует, что разделяемый ресурс потоков будет одновременно использоваться только одним потоком. 
    </p>
    <p>
        <b>synchronized</b> гарантирует, что потоки пришедшие к синхронизируемому коду становятся в очередь и будут захватывать блокировку в порядке очереди. Использование Lock это не гарантирует. Использование synchronized уменьшает возможность допущения ошибки, ибо сама jvm строит код, который гарантирует то, что блокировка в случае чего будет освобождена. В то же время Lock предоставляет больше гибкости, таких как методы tryLock, lockInterrupt, lockTimeout и т.д., а также позволяет освободить блокировку в scope, отличном от того, в котором блокировка была захвачена. В то же время synchronized позволяет внутри себя использовать на объектах синхронизации методы  wait, notify.        
    </p>
    <p>
        <b>wait()</b>: освобождает монитор и переводит вызывающий поток в состояние ожидания до тех пор, пока другой поток не вызовет метод notify()
    </p>
    <p>
        <b>notify()</b>: продолжает работу потока, у которого ранее был вызван метод wait()
    </p>
    <p>
        <b>notifyAll()</b>: возобновляет работу всех потоков, у которых ранее был вызван метод wait()
    </p>
    <p>
        Использование слова synchronize на static-методе помечает весь класс как <i>synchronize</i>.
    </p>
  </div>
</BODY>
</HTML>