<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//RU">
<HTML>
<HEAD>
<LINK rel=stylesheet href="../../css/styles.css" type=text/css>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1251">
<META HTTP-EQUIV="Content-Language" CONTENT="ru">
<title>Тема №13</title>
<base target="_top">
</HEAD>
<BODY>
  <div class="title-1">
    Тема №13 "Преобразование типов"
  </div>
  <div class="content">

    <div class="title-2">
        13.1 Виды преобразований.
    </div>
    <p>
        В Java предусмотрено семь видов приведений:

тождественное (identity);
расширение примитивного типа (widening primitive);
сужение примитивного типа (narrowing primitive);
расширение объектного типа (widening reference);
сужение объектного типа (narrowing reference);
преобразование к строке (String);
запрещенные преобразования (forbidden).
        
    </p>
    <div class="title-2">
        13.2  Тождественное преобразование.
    </div>
    <p>
        Самым простым является тождественное преобразование. В Java преобразование выражения любого типа к точно такому же типу всегда допустимо и успешно выполняется.
     Это важно для возможности утверждать с теоретической точки зрения, что любой тип в Java может участвовать в преобразовании, хотя бы в тождественном.
    </p>
        <div class="title-2">
        13.3 Преобразование примитивных типов.
    </div>
    <p>
        ля простых типов расширение означает, что осуществляется переход от менее емкого типа к более ёмкому. Например, от типа byte (длина 1 байт) к типу int (длина 4 байта). Такие преобразование безопасны в том смысле, что новый тип всегда гарантировано вмещает в себя все данные, которые хранились в старом типе, и таким образом не происходит потери данных. Именно поэтому компилятор осуществляет его сам, незаметно для разработчика:

byte b=3;
     int a=b;

Следующие 19 преобразований являются расширяющими:
От byte к short, int, long, float, double

От short к int, long, float, double

От char к int, long, float, double

От int к long, float, double

От long к float, double

От float к double
Обратите внимание, что нельзя провести преобразование к типу char от типов меньшей или равной длины (byte, short) или, наоборот, к short от char без потери данных. Это связано с тем, что char, в отличие от остальных целочисленных типов, является знаковым.
    </p>
        <div class="title-2">
        13.4 Преобразование ссылочных типов.
    </div>
    <p>
        Преобразование объектных типов лучше всего иллюстрируется с помощью дерева наследования. Рассмотрим небольшой пример наследования:

class Parent {
     int x;
}

class ChildY extends Parent {
     int y;
}

class ChildZ extends Parent {
     int z;
}

В каждом классе объявлено поле с уникальным именем. Будем рассматривать это поле как пример набора уникальных свойств, присущи некоторому объектному типу.
     Объекты класса Parent обладают только одним полем x, а значит, только ссылки типа Parent могут ссылаться на такие объекты. Объекты класса ChildY обладают полем y и полем x, полученным по наследству от класса Parent. Стало быть, на такие объекты могут указывать ссылки типа ChildY  или Parent. Пример:

Parent p = new ChildY();

     Обратите внимание, что с помощью такой ссылки p можно обращаться лишь к полю x созданного объекта. Поле y недоступно, так как компилятор, проверяя корректность выражения p.y, не может предугадать, что ссылка p будет указывать на объект типа ChildY во время исполнения программы. Он анализирует лишь тип самой переменной, а она объявлена как Parent, но в этом классе нет поля y, что и вызовет ошибку компиляции.
     Аналогично, объекты класса ChildZ обладают полем z и полем x, полученным по наследству от класса Parent. Значит, на такие объекты могут указывать ссылки типа ChildZ и Parent.
     Таким образом, ссылки типа Parent могут указать на объект любого из трех рассматриваемых типов, а ссылки типа ChildY и ChildZ – только на объекты точно такого же типа. Теперь можно перейти к преобразования ссылочных типов на основе такого дерева наследования.
     Расширение означает переход от более конкретного типа к менее конкретному, т.е. переход от детей к родителям. Подобно случаю с примитивными типами, этот переход производиться самой JVM при необходимости и «незаметен» для разработчика, то есть не требует никаких специальных преобразования.

Parent p1=new ChildY();
Parent p2=new ChildZ();

В обеих строках переменным типа Parent присваивается значение другого типа, а значит, происходит преобразование. Поскольку это расширение, оно производиться автоматически и всегда успешно.
    </p>
        <div class="title-2">
        13.5 Запрещенные преобразования. 
    </div>
    <p>
        Не все переходы между произвольными типами допустимы. Например, к запрещенным преобразованиям относятся: переходы от любого ссылочного типа к примитивному и наоборот (кроме преобразования к строке), boolean можно привести только к этому типу или же к строке. Кроме того невозможно привести друг к другу, классы находящиеся на соседних ветвях дерева наследования. В примере, который рассматривался для иллюстрации ссылочных типов, переход от ChildY к ChildZ запрещен.
     Этим список запрещенных преобразований не исчерпывается. Он довольно широк и в тоже время все варианты достаточно очевидны, поэтому подробно рассматриваться не будут. Желающие могут получить полную информацию из спецификации.
     Разумеется, попытка осуществить запрещенное преобразование вызовет ошибку.
    </p>
        <div class="title-2">
        13.6 Применение приведений
    </div>
    <p>
           Ситуации применения преобразования типов могут быть сгруппированы следующим образом:
Присвоение значений переменным (assignment). Не все переходы допустимы при таком преобразовании – ограничения выбраны таким образом, чтобы не могла возникнуть исключительная ситуация.

Вызов метода. Это преобразование применяется к аргументам вызываемого метода или конструктора. Такое приведение никогда не порождает ошибок. Так же приведение осуществляется при возвращении значения метода.

Явное приведение. В этом случае явно указывается, к какому типу требуется привести исходное значение.

Оператор конкатенации производит преобразование к строке своих аргументов.

Числовое расширение. Числовые операции могут потребовать изменения типа аргумента(ов). Это преобразование имеет особое название – расширенное, так как выбор целевого типа может зависеть не только от исходного значения, но и от второго аргумента операции.
    </p>



</BODY>
</HTML>