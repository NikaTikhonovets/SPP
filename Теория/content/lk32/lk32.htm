<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//RU">
<HTML>

<HEAD>
    <LINK rel=stylesheet href="../../css/styles.css" type=text/css>
    <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1251">
    <META HTTP-EQUIV="Content-Language" CONTENT="ru">
    <title>Тема №32</title>
    <base target="_top">
</HEAD>

<BODY>
    <div class="title-1">
        Тема №32 "Spring. АОП"
    </div>
    <div class="content">
        <p>
            <b>Аспектно-ориентированное программирование (АОП)</b> — парадигма программирования, основанная на идее разделения
            функциональности для улучшения разбиения программы на модули.
        </p>
        <p>
            Существующие парадигмы программирования — процедурное, модульное, объектно-ориентированное программирование (ООП) и предметно-ориентированное
            проектирование — предоставляют определённые способы для разделения и выделения функциональности: функции, модули,
            классы, но некоторую функциональность с помощью предложенных методов невозможно выделить в отдельные сущности.
            Такую функциональность называют сквозной (от англ. scattered — разбросанный или англ. tangled — переплетённый),
            так как её реализация распределена по различным модулям программы. Сквозная функциональность приводит к рассредоточенному
            и запутанному коду, сложному для понимания и сопровождения.
        </p>
        <p>
            Ведение лога и обработка исключений — типичные примеры сквозной функциональности. Другие примеры: трассировка; аутентификация
            и проверка прав доступа; контрактное программирование (в частности, проверка пред- и постусловий). Для программы,
            написанной в парадигме ООП, любая функциональность, по которой не была проведена декомпозиция, является сквозной.
        </p>
        <p>
            Все языки АОП предоставляют средства для выделения сквозной функциональности в отдельную сущность. Так как AspectJ является
            родоначальником этого направления, используемые в этом расширении концепции распространились на большинство языков
            АОП.
        </p>
        <br>
        <p>
            Основные понятия АОП:
            <ul class="list">
                <li>
                    <i>Аспект</i> (англ. aspect) — модуль или класс, реализующий сквозную функциональность. Аспект изменяет
                    поведение остального кода, применяя совет в точках соединения, определённых некоторым срезом.</li>
                <li>
                    <i>Совет</i> (англ. advice) — средство оформления кода, которое должно быть вызвано из точки соединения.
                    Совет может быть выполнен до, после или вместо точки соединения.</li>
                <li>
                    <i>Точка соединения</i> (англ. join point) — точка в выполняемой программе, где следует применить совет.
                    Многие реализации АОП позволяют использовать вызовы методов и обращения к полям объекта в качестве точек
                    соединения.
                </li>
                <li>
                    <i>Срез</i> (англ. pointcut) — набор точек соединения. Срез определяет, подходит ли данная точка соединения
                    к данному совету. Самые удобные реализации АОП используют для определения срезов синтаксис основного
                    языка (например, в AspectJ применяются Java-сигнатуры) и допускают их повторное использование с помощью
                    переименования и комбинирования.</li>
                <li>
                    <i>Внедрение</i> (англ. introduction, введение) — изменение структуры класса и/или изменение иерархии наследования
                    для добавления функциональности аспекта в инородный код. Обычно реализуется с помощью некоторого метаобъектного
                    протокола (англ. metaobject protocol, MOP).</li>
            </ul>
        </p>
        <p>
            Spring AOP:
            <ul class="list">
                <li>Написан на чистом Java.</li>
                <li>Не использует сторонних компиляторов.</li>
                <li>Урезанная поддержка АОП.</li>
                <li>Интеграция с AspectJ.</li>
                <li>Поддержка аннотаций @AspectJ.</li>
                <li>Часть Spring Framework.</li>
            </ul>
        </p>
        <p>
            При использовании фреймворка Spring, аспекты вплетаются в компоненты во время выполнения посредством обертывания их прокси-классами.
            прокси-класс играет роль целевого компонента, перехватывая вызовы методов и передавая эти вызовы целевому компоненту.
            Между моментами времени, когда прокси-объект перехватывает вызов метода, и вызовом метода целевого компонента
            выполняется логика аспекта.
        </p>
        <p>
            В Spring перехватчики реализуют интерфейс org.aopalliance.intercept.MethodInterceptor. Он содержит единственный метод: public
            Object invoke(MethodInvocation invocation) throws Throwable. Объект MethodInvocation выполняет две основные функции:
            во-первых, он содержит контекст вызова (а именно, имя перехваченного вызова), а во-вторых, предоставляет метод
            proceed, который передает управление целевому объекту.
        </p>
        <br>
        <p>
            AspectJ обладает довольно большим объёмом поддерживаемых срезов точек соединения. Ниже приведены основные из них:
            <ul class="list">
                <li>execution(static * com.xyz..*.*(..)) – выполнение кода любого статического метода в пакете com.xyz;</li>
                <li>call(void MyInterface.*(..)) – вызов любого метода, возвращающего void, интерфейса MyInterface;</li>
                <li>initialization(MyClass || MyOtherClass) – инициализация класса MyClass или MyOtherClass;</li>
                <li>staticinitialization(MyClass+ && !MyClass) – статическая инициализация класса, имя которого начинается на MyClass, но не сам MyClass;</li>
                <li>handler(ArrayOutOfBoundsException) – выполнение обработчика исключения ArrayOutOfBoundsException;</li>
                <li>get/set(static int MyClass.x) — чтение / запись свойства x класса MyClass;</li>
                <li>this/target(MyClass) – выполнение точки соединения, соответствующей объекту типа MyClass;</li>
                <li>args(Integer) – выполнение точки соединения, в которой доступен аргумент типа Integer;</li>
                <li>if(thisJoinPoint.getKind().equals(«call»)) – совпадает со всеми точками соединения, в которых заданное выражение истинно;</li>
                <li>within/withincode(MyClass) — совпадает со всеми точками соединения, встречающимися в коде заданного класса;</li>
                <li>cflow/cflowbelow(call(void MyClass.test())) – совпадает со всеми точками соединения, встречающимися в потоке выполнения заданного среза;</li>
                <li>@annotation(MyAnnotation) – выполнение точки соединения, цель которой помечена аннотацией @MyAnnotation.</li>
            </ul>
        </p>
    </div>
</BODY>

</HTML>